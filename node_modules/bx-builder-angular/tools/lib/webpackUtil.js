const _ = require('lodash');
const glob = require('glob');
const path = require('path');

const webpackUtil = {

    chunk: {
        name: 'common_bundle',
        // 2개 이상 중복되는 경우, chunk file 로 생성한다.
        minChunks: 2,
        chunks: [],
        enable: true
    },

    get chunks() {
        return this.chunk.chunks;
    },

    set chunks(chunks) {

        this.chunk.chunks = chunks;
    },

    get enableChunk() {
        return this.chunk.enable;
    },

    set enableChunk(isEnable) {
        this.chunk.enable = isEnable;
    },

    get minChunks() {
        return this.chunk.minChunks;
    },

    createEntry(envConfig) {

        var entry;

        const userBundle = envConfig.build.js.bundle;
        //const srcPath = envConfig.tools.path.src;
        const appPath = envConfig.tools.path.app;

        if (_isWildCard(userBundle)){

            entry = _getWildEntry(appPath);
        }
        else if (_.isPlainObject(userBundle) && !_.isEmpty(userBundle)) {

            entry = _makeGroupingEntry(userBundle, appPath);
        }
        else {

            entry = _getDefaultEntry(appPath);
        }

        if (!_.isPlainObject(entry) && _.isEmpty(entry)) throw new Error('create entry Task fail');

        this.chunks = Object.keys(entry);

        if (this.chunks.length === 1) this.enableChunk = false;

        return entry;
    },

    getChunkName: function() {
        const chunkName = this.chunk.name;
        return chunkName;
    },

    getChunkFileName: function() {
        const chunkFileName = `${this.getChunkName()}.js`;
        return chunkFileName;
    }
};

/**
 * 와일드 카이드 유무 반환 함수
 * @param {all} bundle
 * @returns {boolean}
 * @private
 */
function _isWildCard(bundle) {
    const wildCard = '*';
    return _.isString(bundle) && bundle === wildCard;
}
/**
 * 와일드 카드의 엔트리 반환 함수
 * @param path
 * @returns {{}}
 * @private
 */
function _getWildEntry(path) {

    const wildEntry = {};
    const _entry = glob.sync(path + '/**/*.js');

    _entry.map((filePath) => {

        const buildPath = filePath.replace(/\S+\/src\//, '').replace(/\.js/, '');

        wildEntry[buildPath] = [filePath];
    });

    return wildEntry;
}
/**
 * 그룹핑 엔트리 반환 함수
 * @param userBundle
 * @param srcPath
 * @returns {{}}
 * @private
 */
function _makeGroupingEntry(userBundle, _path){

    const entry = {};

    Object.keys(userBundle).map((key) => {

        const errorMsg = 'build.config ' + 'entry 의 ' + key + '은(는) String 또는 String[] 로 만 설정할 수 있습니다.';

        const entryForKey = userBundle[key];

        if (!_.isArray(entryForKey) && !_.isString(entryForKey)) {
            throw new Error(errorMsg);
        }

        var tmpEntry = [];

        const ext = '.js';
        const replacePtn = /\..+$/gi;

        tmpEntry = tmpEntry.concat(entryForKey);

        tmpEntry.map((v) => {

            if (!_.isString(v)) {
                throw new Error(errorMsg);
            }

            v = v.replace(replacePtn, '');

            const entryArray = glob.sync(path.join(_path, (v + ext)));

            if (entryArray.length === 0) return;
            if (!entry[key]) entry[key] = [];

            entry[key] = entry[key].concat(entryArray);
        });
    });

    return entry;
}
/**
 * 기본 엔트리 반환 함수
 * @param path
 * @returns {{app: *}}
 * @private
 */
function _getDefaultEntry(path) {
    return {
        "app": glob.sync(`${path}/**/*.js`)
    };
}

module.exports = webpackUtil;