
/**
 * Created by sgjeon on 16. 4. 8..
 */

const os = require('os');
const clc = require('cli-color');
const path = require('path');
const fs = require('fs');

const _ = require('lodash');
const glob = require('glob');

module.exports = {

    isWindows: function(){
        return os.platform() === 'win32' ? true : false;
    },
    replaceSassToCss: function(v){

        var replaceText = '';
        var sassReg = /\.sass|\.scss/g;

        if (!sassReg.test(v)) return v;

        if (!_.isString(v)) return replaceText;

        replaceText = v.replace(sassReg, '.css');

        return replaceText;
    },
    replaceCSSPathToBuildAssetsPath: function(v){

        if (!_.isString(v)) return this;

        const config  = require('../config');

        const toolPath = config.path;

        const srcPath = toolPath.src;
        const nodeModulesPath = toolPath.nodeModules;
        const buildPath = toolPath.build;

        if (v.indexOf(srcPath) > -1){
            v = v.replace(srcPath, buildPath);
        }
        else if (v.indexOf(nodeModulesPath) > -1){
            v = v.replace(nodeModulesPath, path.join(buildPath, 'assets'));
        }

        return v;
    },
    getFileInfo: function(_path){

        const ret = {};
        const state = fs.lstatSync(_path);

        if (!state.isFile()) return ret;

        const fileName = path.basename(_path);
        const regExp = new RegExp(`${fileName}$`);
        const parentPath = _path.replace(regExp, '');

        const lastDotIndex = fileName.lastIndexOf('.');
        const ext = fileName.substr(lastDotIndex + 1);

        ret.name = fileName;
        ret.path = parentPath;
        ret.ext = ext;

        return ret;
    },
    filterCopyFiles: function(copyFiles, type, cwdType){

        if (!_.isArray(copyFiles)) return [];
        type = !_.isString(type) ? 'js' : type;
        cwdType = !_.isString(cwdType) ? 'dest' : cwdType;

        const ret = [];

        _.forEach(copyFiles, (v) => {

            const src = v.src;
            const cwd = v.cwd;
            const dest = v.dest;

            _.forEach(src, (v) => {

                const entry = glob.sync(cwd + '/' + v);

                _.forEach(entry, (vv) => {

                    const ext = this.getFileInfo(vv).ext;

                    if (type === ext){

                        if (cwdType === 'dest'){
                            ret.push(dest + path.join(vv).replace(cwd, ''));
                        }
                        else if (cwdType === 'cwd'){
                            ret.push(path.join(vv));
                        }
                    }
                });
            });
        });

        return ret;
    },
    arrayToObject: function(v){

        if (!_.isArray(v)) return;

        var ret = {};

        _.forEach(v, (vv) => { ret[vv] = vv; });

        return ret;
    },
    excludeFilePaths: function(files, excludeFilePaths){

        if (!_.isArray(files)) return [];
        if (!_.isString(excludeFilePaths) && !_.isArray(excludeFilePaths)) return [];

        excludeFilePaths = _.isString(excludeFilePaths) ? [excludeFilePaths] : excludeFilePaths;

        files = _.clone(files);

        var tmpFiles = [];
        _.forEach(files, v => { tmpFiles.push(path.join(v)); });

        var tmpExcludeFilePaths = [];
        _.forEach(excludeFilePaths, v => { tmpExcludeFilePaths.push(path.join(v)); });

        // 배열 타입을 객체 타입으로 변환시킨다.
        files = this.arrayToObject(tmpFiles);
        // 배열 타입을 객체 타입으로 변환시킨다.
        excludeFilePaths = this.arrayToObject(tmpExcludeFilePaths);

        _.map(excludeFilePaths, v => {

            if (files[v]) delete files[v];
        });

        return _.toArray(files);
    }
};