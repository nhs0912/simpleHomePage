
/**
 * Created by sgjeon on 16. 4. 8..
 */

const _ = require('lodash');
const path = require('path');

const htmlHintPluginBxuip = require('htmlhint-plugin-bxuip');
const bxuipRules = htmlHintPluginBxuip.rules;
const bxuipCustomRules = htmlHintPluginBxuip.customRules;

const taskName = 'htmlhintplus';

module.exports = function(grunt, options){

    const config = grunt.config.get('config');

    grunt.loadNpmTasks('grunt-htmlhint-plus');

    // https://github.com/poppinlp/grunt-htmlhint-plus
    const htmlHintPlus = {
        html: {
            options: {
                //htmlhintrc: '<%=config.tools.relativePath.root%>',
                force: true,
                // 만약 rules 프로퍼티에 값이 없을 경우, 아래 extendRules 프로퍼티가 적용되지않는 문제가 있다.(즉 rule 프로퍼티는 어떤(false 값) 형태라도 반드시 존해야한다)
                rules: bxuipRules,
                customRules: [],
                // true: 기본 룰을 확장 시킨다.
                // false: 지정된 룰만 실행한다.
                extendRules: false,
                output: ['console']
            },
            src: []
        }
    };

    (function initHtmlHintPlus(){

        var rules = {};
        var customRules = [];
        var buildObject = config.build;

        if (
        !buildObject.linters ||
        !buildObject.linters.html ||
        !buildObject.linters.html.rules ||
        !_.size(buildObject.linters.html.rules)) return;

        var configRules = buildObject.linters.html.rules;

        if (!_.isString(configRules) && !_.isPlainObject(configRules)) return;

        if (_.isString(configRules)){

            if (configRules !== '*'){
                grunt.fail.fatal('[' + taskName + '] Please defined the wildCard character.');
            }

            _.map(bxuipCustomRules, function(v, k){

                rules[k] = true;
                customRules.push(v.rulePath.replace(config.tools.path.root, ''));
            });
        }
        else if (_.isPlainObject(configRules)){

            _.map(bxuipCustomRules, function(v, k){

                rules[k] = false;

                if (configRules[k] === 'error'){
                    rules[k] = true;
                    customRules.push(v.rulePath.replace(config.tools.path.root, ''));
                }
            });
        }

        const ext = '.html';
        const defaultSrc = `**/*${ext}`;
        const src = _.isArray(buildObject.linters.html.src) ? buildObject.linters.html.src : [defaultSrc];

        const replacePtn = /\..+$/gi;

        const _src = [];

        _.forEach(src, v => {

            v = v.replace(replacePtn, '');

            _src.push(path.join(config.tools.path.app, (v + ext)));

        });

        htmlHintPlus.html.src = _src;

        htmlHintPlus.html.options.rules = rules;
        htmlHintPlus.html.options.customRules = customRules;

    })();


    return htmlHintPlus;
};