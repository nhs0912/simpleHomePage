/**
 * Created by sgjeon on 16. 4. 5..
 */

const webpack = require('webpack');

// https://www.npmjs.com/package/webpack-config
const webpackConfig = require('webpack-config');

// path module
const path = require("path");

// (directory)pattern 을 적용할 수 있는 file module
// https://github.com/isaacs/node-glob
const glob = require("glob");

const process = require("process");

// 환경 설정
const envConfig = webpackConfig.environment.get('config');

// file system
const fs = require('fs');

// lodash
const _ = require('lodash');

const _console = require('../lib/console');
const webpackUtil = require('../lib/webpackUtil');

// https://www.npmjs.com/package/fix-moduleid-and-chunkid-plugin
const fixModuleIdAndChunkIdPlugin = require('fix-moduleid-and-chunkid-plugin');

// shelljs
require('shelljs/global');
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// config
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

const config = {

    context: envConfig.tools.path.app,
    entry: webpackUtil.createEntry(envConfig),
    output: {
        // 빌드된 파일이 위치할 (webpack.x.common.config.js 로 부터의) 상대 경로
        path: envConfig.tools.path.build
    },
    // externals, resolve, alias 에 대한 자세한 설명
    // http://stackoverflow.com/questions/23305599/webpack-provideplugin-vs-externals
    externals: function(){

        if (!envConfig.build['js']) return {};

        var js = envConfig.build['js'];
        var ret = {};

        if (js['external']){

            var external = js['external'];

            for (var loadType in external){

                if (!external[loadType]) continue;

                for (var name in external[loadType]){

                    var globalVariable = external[loadType][name]['globalVariable'];
                    var absolutePath = external[loadType][name]['absolutePath'];

                    // external 프로퍼티에 할당될 JS 파일은 반드시 absolutePath 프로퍼티와 globalVariable 프로퍼티를 가져야만한다.
                    if (_.isEmpty(absolutePath)){
                        _console.error('Cannot find absolutePath property in ' + name + ' property.');
                        process.exit(1);
                    }

                    // 파일이 해당 위치에 존재 하는지만 검사
                    if (!fs.existsSync(absolutePath)) {
                        _console.error('Cannot find module in this path >> ' + absolutePath);
                        process.exit(1);
                    }

                    // 만약 globalVariable을 지정 하지 않았다면
                    // common/external.js 와 app.js에 중복으로 들어는 문제가 발생 한다
                    // globalVariable이 반드시 값이 들어 가도록 name 값으로 지정한다
                    if (_.isUndefined(globalVariable)) {

                        // 영문, $, _ 를 제외한것은 모두 지운다.
                        var ptn = /[^$_a-zA-Z0-9]/gi;

                        globalVariable = name.replace(ptn, '');

                        _console.warn('[Warning]: If globalVariable is not specified, you should can set ' + globalVariable + ' global variable');
                    }

                    ret[name] = globalVariable;
                }

            }
        }

        return ret;

    }(),
    // lazy-loading 을 위한 로더
    // https://www.npmjs.com/package/bundle-loader
    module: {
        loaders: function(){

            var ret = [];
            var loaders = envConfig.build.loaders;
            var js = envConfig.build.js;

            var loader = null;

            var enabledES2015 = false;
            var enabledStrictMode = true;

            if (_.isPlainObject(loaders) && _.isBoolean(loaders.es2015)){
                enabledES2015 = loaders.es2015;
            }

            if (_.isPlainObject(js) && _.isBoolean(js.strictMode)){
                enabledStrictMode = js.strictMode;
            }

            // ES2015 모드가 true 이거나, strictMode 가 true 인 경우
            if (enabledES2015 || enabledStrictMode){

                loader = {

                    test: /\.(js)$/,
                    include: envConfig.tools.path.app,
                    exclude: /(node_modules)/,
                    loader: 'babel-loader',
                    query: {

                        // https://github.com/babel/babel-loader#options

                        // 캐시 활성화를 통해, 빌드 과정을 최적화 시킨다.
                        // 캐시 디렉토리: node_modules/.cache

                        // cacheDirectory: true 인 경우 strict Mode 지원하지 않음.
                        cacheDirectory: true,
                        presets: [],
                        plugins: []
                    }
                };

                if (enabledES2015){
                    loader.query.presets.push('es2015');
                    // babel-polyfill 을 위한, transfer module
                    loader.query.plugins.push(['transform-runtime']);
                }

                if (enabledStrictMode){
                    loader.query.plugins.push(['transform-strict-mode', {
                        strict: envConfig.build.js.strictMode,
                        strictMode: envConfig.build.js.strictMode
                    }]);
                }
            }

            loader && ret.push(loader);

            return ret;
        }(),
        noParse: []
    },
    // require 를 통해 가져오는 모듈명을 어떻게 해석할지에 대한 옵션을 정의한다.
    // https://github.com/webpack/docs/wiki/configuration
    resolve: {
        alias: {},
        modulesDirectories: ["node_modules"],
        /*
         모듈명 뒤에 여기 명시된 확장자명들을 붙여보며 탐색을 수행한다. 즉, 위의 설정 파일에서처럼 extensions: ['', '.js', '.css']
         으로 설정되어 있으면 require('abc')를 resolve 하기 위해 abc, abc.js, abc.css 로 탐색한다.
         */
        extensions: ['', '.js']
    },
    cache: true,
    plugins: [
        // require('jquery') 메서드를 통해, 로드된 JS 파일을 내부적으로 alias($$) 이름으로 사용할 수 있게 해준다.
        new webpack.ProvidePlugin(function(){

            if (!envConfig.build['js']) return {};

            var js = envConfig.build['js'];
            var ret = {};

            if (js['external']){

                var external = js['external'];

                for (var loadType in external){

                    if (!external[loadType]) continue;

                    for (var name in external[loadType]){

                        var globalVariable = external[loadType][name]['globalVariable'];
                        var alias = external[loadType][name]['alias'];

                        if (!globalVariable || !alias) continue;

                        ret[alias] = name;
                    }
                }
            }

            return ret;

        }()),
        // 중복 코드를 막기위한 옵션
        // https://github.com/webpack/docs/wiki/optimization#minimize
        new webpack.optimize.DedupePlugin(),
        // chunkId 를 가변 index(숫자) 에서 파일 경로로 fix 시킨다.(bundle 활성화시 반드시 필요한 기능)
        new fixModuleIdAndChunkIdPlugin(),
        // 빌드 에러 시, 예외 처리
        function (){

            // 빌드 에러 시, 백업된 빌드 폴더를 원복 시킨다.
            // http://stackoverflow.com/questions/30267255/webpack-plugin-catch-errors-in-build-process
            this.plugin('done', function (stats) {

                var buildPath = envConfig.tools.path.build;
                var tmpBuildPath = envConfig.tools.path.tmpBuild;

                var errors = stats.compilation.errors;
                var restore = envConfig.build.restore;

                var enabledBackMode = _.isPlainObject(restore) && _.isBoolean(restore.backup) && restore.backup;

                var time = new Date().getTime();

                if (errors && errors.length){

                    if (enabledBackMode){

                        rm('-rf', buildPath);
                        cp('-R', tmpBuildPath + '/', buildPath);

                        var logPath = envConfig.build.restore.logPath;

                        if (_.isString(logPath)){

                            // 로그 메시지를 가져온다.
                            var msg = _parseMessage(errors[0]);

                            // logPath 폴더가 없을 경우
                            if (!fs.existsSync(logPath)) mkdir(logPath);

                            // 로그 파일 생성
                            fs.writeFileSync(logPath + '/' + time + '.txt', msg);
                        }

                        // 임시 폴더를 삭제한다.
                        rm('-rf', tmpBuildPath);

                        // 프로세스를 중지시킨다.
                        process.exit(1);
                    }
                }
                else{

                    // 임시 폴더를 삭제한다.
                    rm('-rf', tmpBuildPath);
                }
            });

            // 로그 메시지를 파싱 후, 반환한다.
            function _parseMessage(errorObject){

                if (!_.isObject(errorObject)) return '';

                var o = {};

                var name = errorObject.name;
                var message = errorObject.message;

                o.name = name;
                o.message = message;
                o.line = -1;
                o.column = -1;

                if (_.isObject(errorObject.error)){

                    var error = errorObject.error.error;
                    o.line = error.loc.line;
                    o.column = error.loc.column;
                }

                return JSON.stringify(o, null, 2);
            }
        }

        //// entry 간의 공통 js 파일을 생성한다.
        //new webpack.optimize.CommonsChunkPlugin({
        //    name: 'common',
        //    filename: 'common.js',
        //    // 등록된 모든 entry point 를 chunks 배열로 할당시켜, 모든 파일들의 공통 번들을 추출한다.
        //    chunks: ['app', 'externals'],
        //    minChunks: 2
        //})
    ]
};

if (webpackUtil.enableChunk) {

    config.plugins.push(new webpack.optimize.CommonsChunkPlugin(function(){

        return {
            name: webpackUtil.getChunkName(),
            filename: webpackUtil.getChunkFileName(),
            // 등록된 모든 entry point 를 chunks 배열로 할당시켜, 모든 파일들의 공통 번들을 추출한다.
            chunks: webpackUtil.chunks,
            // chunks 에 할당 된 부분의 공통된 부분이 아래의 숫자 이상인 경우, fileName 에 해당하는 JS file 로 이관
            minChunks: webpackUtil.minChunks
        };
    }()));
}


module.exports = new webpackConfig().merge(config);