
const _ = require('lodash');
const util = require('../lib/util.js');
const msg = require('../lib/msg.json');

module.exports = {
    id: 'bxuip-id-class-value',
    description: '',
    init: function(parser, reporter){

        const self = this;

        const rules = {
            "id": {
                ptn: /[a-z_\d{}()|?:.$]+/,
                msg: msg['ko'][self.id]['id']
            },
            "class": {
                ptn: /[a-z-\d{}()|?:.$]+/,
                msg: msg['ko'][self.id]['class']
            },
            "firstNumber": {
                ptn: /^([a-z{:]{1})/,
                msg: msg['ko'][self.id]['firstNumber']
            }
        };

        const msgObject = {};

        parser.addListener('tagstart', (event) => {

            const tagName = event.tagName.toLowerCase();
            const attrs = event.attrs;
            const col = event.col + event.tagName.length + 1;
            const line = event.line;
            const raw = event.raw;

            _.map(attrs, (v) => {

                const attrName = v.name.toLowerCase();

                // 속성값
                var value = v.value;

                // AngularJS 표현식을 사용한 경우에는, 전달받은 문자열을 소문자로 변경한다.(린팅 과정을 무력화하기위한 수단)
                if (/[{}():|$.]{1,}/g.test(value)){
                    value = value.toLowerCase();
                }

                if (attrName === 'id'){
                    // 아이디 속성값의 공백을 제거한다.
                    value = value.replace(/\s/g, '');
                }
                else if (attrName === 'class'){
                    // 클래스 속성값은 각 클래스값을 공백으로 분류한다.
                    value = value.split(/\s/);
                }

                if (attrName === 'id'){

                    if (value){

                        _.map(rules, (v, k) => {

                            var mt = value.match(v.ptn);

                            msgObject.ruleId = self.id;
                            msgObject.ruleMsg = v.msg;
                            msgObject.line = line;
                            msgObject.raw = raw;

                            if (!mt){
                                reporter.error(util.getMessage(msgObject), event.line, col, self);
                            }
                            else{

                                if (k === 'id'){

                                    const matchString = mt[0];

                                    // 정규 표현식에의해 매칭된 텍스트 길이와, 원본 길이가 다를 경우
                                    if (matchString.length !== value.length){
                                        reporter.error(util.getMessage(msgObject), event.line, col, self);
                                    }
                                }
                            }
                        });
                    }
                }
                else if (attrName === 'class'){

                    _.forEach(value, (v, k) => {

                        if (v){

                            _.map(rules, (vv, kk) => {

                                var mt = v.match(vv.ptn);

                                msgObject.ruleId = self.id;
                                msgObject.ruleMsg = vv.msg;
                                msgObject.line = line;
                                msgObject.raw = raw;

                                if (!mt){
                                    reporter.error(util.getMessage(msgObject), event.line, col, self);
                                }
                                else{

                                    if (kk === 'class'){

                                        const matchString = mt[0];

                                        //console.log(matchString, v);

                                        // 정규 표현식에의해 매칭된 텍스트 길이와, 원본 길이가 다를 경우
                                        if (matchString.length !== v.length){
                                            reporter.error(util.getMessage(msgObject), event.line, col, self);
                                        }
                                    }
                                }
                            });
                        }
                    });
                }
            });
        });
    }
};